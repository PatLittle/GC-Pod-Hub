{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"I have made my first golang CLI","url":"https://www.reddit.com/r/golang/comments/1inb0md/i_have_made_my_first_golang_cli/","date":1739311925,"author":"/u/Halabito8","guid":336,"unread":true,"content":"<p>I built a CLI tool in Go to help me stay on top of my ClickUp tasks. I’ve got a bunch of lists, and it’s a pain to figure out what to tackle first since ClickUp doesn’t let me see everything in one place easily.</p><p>This tool pulls all my to-dos and in-progress tasks, then generates two reports:</p><ol><li>A single merged list sorted by priority and due date.</li><li>Tasks grouped by their respective lists.</li></ol><p>Now, I can quickly see what’s due today and what actually matters. It’s just a reporting tool for now, but it’s already making my workflow way smoother.</p>","contentLength":548,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go 1.24 is released (self.golang)","url":"https://www.reddit.com/r/golang/comments/1in5nuw/go_124_is_released_selfgolang/","date":1739298827,"author":"/u/rtuidrvsbrdiusbrvjdf","guid":340,"unread":true,"content":"   submitted by   <a href=\"https://www.reddit.com/user/rtuidrvsbrdiusbrvjdf\"> /u/rtuidrvsbrdiusbrvjdf </a>","contentLength":43,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go 1.24.0 tagged","url":"https://www.reddit.com/r/golang/comments/1in559i/go_1240_tagged/","date":1739297568,"author":"/u/khnorgaard","guid":341,"unread":true,"content":"   submitted by   <a href=\"https://www.reddit.com/user/khnorgaard\"> /u/khnorgaard </a>","contentLength":33,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Simple strategy to understand error handling in Go","url":"https://www.reddit.com/r/golang/comments/1in0tiw/simple_strategy_to_understand_error_handling_in_go/","date":1739286833,"author":"/u/zakariachahboun","guid":338,"unread":true,"content":"<p>Error handling in Go is a topic that often sparks debate. Some prefer wrapping errors for more context, while others stick to returning and checking errors as simply as possible.</p><p>I’ve been refining my own approach over time, balancing readability, maintainability, and practicality. I recently wrote an article discussing some key strategies and best practices I use. Would love to hear how others handle errors in their Go projects !</p><p>This is a summary of the strategy for beginners:</p><table><tbody><tr><td>Low-level functions (utils, DB calls, API calls, etc.)</td><td>Return errors as-is (don't log)</td><td>Callers higher up should decide how to handle the error</td></tr><tr><td>Business logic (services, middle-layer functions)</td><td>Adds context while preserving original error details</td></tr><tr><td>HTTP Handlers, CLI commands, or main()</td><td>Log errors, return user-friendly messages</td><td>Avoid exposing internal details to users</td></tr></tbody></table><p>How do you structure error handling in your Go projects? Any techniques or best practices that have worked well for you?</p>","contentLength":963,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rendering React on Golang with V8Go","url":"https://itnext.io/rendering-react-on-golang-with-v8go-fd84cdad2844?source=friends_link&amp;sk=040bff7b0a2ca9d02179c7897476ace4","date":1739279016,"author":"/u/congolomera","guid":339,"unread":true,"content":"<p>Server-side rendering (SSR) is essential for improving web performance, SEO, and initial page load experience. React provides built-in SSR capabilities through , but this typically requires a Node.js environment.</p><p>What if we want to run and render React components without Node.js? This could be useful in cases where:</p><ul><li>We’re building a Go-based web server and want to keep everything self-contained.</li><li>We don’t want to spin up an external Node.js process just to render React.</li><li>We’re running in environments with limited dependencies, such as embedded systems or lightweight containers.</li></ul><p>For more details, you can see the full source code on GitHub</p><p><a href=\"https://github.com/highercomve/go-react-ssr/blob/849587bca03c8ef5cadd4f39333ca978804c539c/modules/server/template.go#L32C1-L37C1\" rel=\"noopener ugc nofollow\" target=\"_blank\">https://github.com/highercomve/go-react-ssr</a></p><p>Instead of running a separate Node.js process, we can embed , the JavaScript engine that powers Chrome, directly into our Go application using .</p><p>This approach provides several benefits:</p><ul><li>: No need to start and communicate with an external Node.js process.</li><li>: Everything runs inside the Go application, reducing complexity.</li><li>: We control how the JavaScript…</li></ul>","contentLength":1038,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1imy2xx/rendering_react_on_golang_with_v8go/"},{"title":"Optimization problems in high-performance programs with Go","url":"https://www.reddit.com/r/golang/comments/1imo7jt/optimization_problems_in_highperformance_programs/","date":1739241393,"author":"/u/JotaEspig","guid":337,"unread":true,"content":"<p>Hello guys, I'm currently working on a chess engine using golang, where one of the most important things about it is the performance. After running a profiler I got this:</p><blockquote><p>Showing nodes accounting for 21.63s, 48.64% of 44.47s totalDropped 1385 nodes (cum &lt;= 0.22s)</p><p>Showing top 15 nodes out of 188</p><p>11.36s 25.55% 25.55% 11.43s 25.70% runtime.cgocall C:\\Program Files\\Go\\src\\runtime\\cgocall.go:167</p><p>2.35s 5.28% 30.83% 2.35s 5.28% runtime.stdcall2 C:\\Program Files\\Go\\src\\runtime\\os_windows.go:1000</p><p>2.06s 4.63% 35.46% 2.06s 4.63% runtime.stdcall1 C:\\Program Files\\Go\\src\\runtime\\os_windows.go:991</p><p>1.06s 2.38% 37.85% 1.06s 2.38% runtime.stdcall0 C:\\Program Files\\Go\\src\\runtime\\os_windows.go:982</p><p>0.71s 1.60% 39.44% 0.71s 1.60% runtime.scanobject C:\\Program Files\\Go\\src\\runtime\\mgcmark.go:1446</p><p>0.68s 1.53% 40.97% 0.68s 1.53% runtime.stdcall3 C:\\Program Files\\Go\\src\\runtime\\os_windows.go:1009</p><p>0.59s 1.33% 42.30% 0.59s 1.33% runtime.procyield C:\\Program Files\\Go\\src\\runtime\\asm_amd64.s:807</p><p>0.50s 1.12% 43.42% 0.50s 1.12% runtime.stdcall4 C:\\Program Files\\Go\\src\\runtime\\os_windows.go:1018</p><p>0.44s 0.99% 44.41% 0.44s 0.99% runtime.stdcall7 C:\\Program Files\\Go\\src\\runtime\\os_windows.go:1045</p><p>0.38s 0.85% 45.27% 0.38s 0.85% runtime.memclrNoHeapPointers C:\\Program Files\\Go\\src\\runtime\\memclr_amd64.s:93</p><p>0.38s 0.85% 46.12% 0.38s 0.85% runtime.scanblock C:\\Program Files\\Go\\src\\runtime\\mgcmark.go:1362</p><p>0.31s 0.7% 46.82% 0.31s 0.7% runtime.scanblock C:\\Program Files\\Go\\src\\runtime\\mgcmark.go:1359</p><p>0.29s 0.65% 47.47% 0.29s 0.65% runtime.(*mspan).base C:\\Program Files\\Go\\src\\runtime\\mheap.go:492</p><p>0.25s 0.56% 48.64% 0.40s 0.9% gce/pkg/chess.(*Board).IsKingInCheck D:\\jotin\\Documents\\Informatica\\projects\\go-chess-engine\\pkg\\chess\\board.go:150</p></blockquote><p>Apparently, the cpu usage is mostly at runtime. Why is that? How can I possibly avoid this?</p><p>I already try to preallocate everythin I can, but not so much improvement.</p><p>At the moment, the program can process and average of 25k nodes per seconds (node is a final position). One of the best engines in the world (Stockfish) runs at 2000 knps (2 million nodes per second). I would love to reach 100 knps. Any idea?</p>","contentLength":2117,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit","go"]}