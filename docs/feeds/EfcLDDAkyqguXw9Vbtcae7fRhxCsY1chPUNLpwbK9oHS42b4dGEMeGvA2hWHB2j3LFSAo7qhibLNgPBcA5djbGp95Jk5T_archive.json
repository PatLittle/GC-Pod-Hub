{"id":"EfcLDDAkyqguXw9Vbtcae7fRhxCsY1chPUNLpwbK9oHS42b4dGEMeGvA2hWHB2j3LFSAo7qhibLNgPBcA5djbGp95Jk5T","title":"top scoring links : programming","displayTitle":"Reddit - Programming","url":"https://www.reddit.com/r/programming/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/programming/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Tech's Dumbest Mistake: Why Firing Programmers for AI Will Destroy Everything","url":"https://defragzone.substack.com/p/techs-dumbest-mistake-why-firing","date":1739310044,"author":"/u/tapvt","guid":416,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ina9ia/techs_dumbest_mistake_why_firing_programmers_for/"},{"title":"Undergraduate Upends a 40-Year-Old Data Science Conjecture","url":"https://www.quantamagazine.org/undergraduate-upends-a-40-year-old-data-science-conjecture-20250210/","date":1739298397,"author":"/u/Stackitu","guid":411,"unread":true,"content":"<p>Together, Krapivin (now a graduate student at the University of Cambridge), Farach-Colton (now at New York University) and Kuszmaul demonstrated in a <a href=\"https://arxiv.org/abs/2501.02305\">January 2025 paper</a> that this new hash table can indeed find elements faster than was considered possible. ln so doing, they had disproved a conjecture long held to be true.</p><p>“It’s an important paper,” said <a href=\"https://ajhconway.com/\">Alex Conway</a> of Cornell Tech in New York City. “Hash tables are among the oldest data structures we have. And they’re still one of the most efficient ways to store data.” Yet open questions remain about how they work, he said. “This paper answers a couple of them in surprising ways.”</p><p>Hash tables have become ubiquitous in computing, partly because of their simplicity and ease of use. They’re designed to allow users to do exactly three things: “query” (search for) an element, delete an element, or insert one into an empty slot. The first hash tables date back to the early 1950s, and computer scientists have studied and used them ever since. Among other things, researchers wanted to figure out the speed limits for some of these operations. How fast, for example, could a new search or insertion possibly be?</p><p>The answer generally depends on the amount of time it takes to find an empty spot in a hash table. This, in turn, typically depends on how full the hash table is. Fullness can be described in terms of an overall percentage — this table is 50% full, that one’s 90% — but researchers often deal with much fuller tables. So instead, they may use a whole number, denoted by , to specify how close the hash table is to 100% full. If  is 100, then the table is 99% full. If  is 1,000, the table is 99.9% full. This measure of fullness offers a convenient way to evaluate how long it should take to perform actions like queries or insertions.</p><p>Researchers have long known that for certain common hash tables, the expected time required to make the worst possible insertion — putting an item into, say, the last remaining open spot — is proportional to . “If your hash table is 99% full,” Kuszmaul said, “it makes sense that you would have to look at around 100 different positions to find a free slot.”</p><p>In a <a href=\"https://dl.acm.org/doi/10.1145/3828.3836\">1985 paper</a>, the computer scientist <a href=\"https://amturing.acm.org/award_winners/yao_1611524.cfm\">Andrew Yao</a>, who would go on to win the A.M. Turing Award, asserted that among hash tables with a specific set of properties, the best way to find an individual element or an empty spot is to just go through potential spots randomly — an approach known as uniform probing. He also stated that, in the worst-case scenario, where you’re searching for the last remaining open spot, you can never do better than . for 40 years, most computer scientists assumed that Yao’s conjecture was true.</p><p>Krapivin was not held back by the conventional wisdom for the simple reason that he was unaware of it. “I did this without knowing about Yao’s conjecture,” &nbsp;he said. His explorations with tiny pointers led to a new kind of hash table — one that did not rely on uniform probing. And for this new hash table, the time required for worst-case queries and insertions is proportional to (log ) — far faster than . This result directly contradicted Yao’s conjecture. Farach-Colton and Kuszmaul helped Krapivin show that (log ) is the optimal, unbeatable bound for the popular class of hash tables Yao had written about.</p><p>“This result is beautiful in that it addresses and solves such a classic problem,” said <a href=\"http://www.cs.cmu.edu/~guyb/\">Guy Blelloch</a> of Carnegie Mellon.</p><p>“It’s not just that they disproved [Yao’s conjecture], they also found the best possible answer to his question,” said <a href=\"https://cs.uwaterloo.ca/about/people/sassadi\">Sepehr Assadi</a> of the University of Waterloo. &nbsp;“We could have gone another 40 years before we knew the right answer.”</p>","contentLength":3730,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1in5hkt/undergraduate_upends_a_40yearold_data_science/"},{"title":"smol-gpu: A tiny RISC-V GPU built to teach modern GPU architecture","url":"https://github.com/Grubre/smol-gpu","date":1739271636,"author":"/u/Direct-Title-3416","guid":415,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1imw1id/smolgpu_a_tiny_riscv_gpu_built_to_teach_modern/"},{"title":"We Replaced Our React Frontend with Go and WebAssembly","url":"https://dagger.io/blog/replaced-react-with-go","date":1739269892,"author":"/u/GarethX","guid":414,"unread":true,"content":"<p>A few weeks ago, we <a href=\"https://dagger.io/blog/dagger-cloud-v3\" rel=\"noopener\">launched Dagger Cloud v3</a>, a completely new user interface for <a href=\"https://dagger.cloud/\" rel=\"noopener\">Dagger Cloud</a>. One of the main differences between v3 and its v2 predecessor is that the new UI is written in <a href=\"https://en.wikipedia.org/wiki/WebAssembly\" rel=\"noopener\">WebAssembly (WASM)</a> using Go. At first glance, this might seem an odd choice - Go typically isn't the first language you think of when deciding to program a Web UI - but we had good reasons. In this blog post, I'll explain why we chose WebAssembly, some of our implementation challenges (and how we worked around them), and the results.</p><h4>Two Codebases = More Work, Fewer Features</h4><p>Dagger works by building up a DAG of operations and evaluating them, often in parallel. By nature, this is a difficult thing to display. To help users make sense of it, we offer <a href=\"https://docs.dagger.io/features/visualization\" rel=\"noopener\">two real-time visualization interfaces</a>: the Dagger terminal UI (TUI), included in the Dagger CLI, and Dagger Cloud, an online Web dashboard. The Dagger TUI is implemented in Go, and Dagger Cloud (pre-v3) was written in React.</p><p>Obviously, we want both user interfaces to be as close to each other as possible. But the actual act of interpreting Dagger's event stream in real-time and producing a UI is pretty involved. Some of the more complex event streams we've seen have hundreds of thousands of OpenTelemetry spans, and managing the data structures around them gets very complicated, very quickly. The Web UI often couldn't keep up with the huge volume of data it had to process and it would become laggy and slow; to fix this performance bottleneck, we were forced into a different implementation model for the React application.</p><p>So, we ended up with two interfaces trying to accomplish the same thing, one of them in one language and ecosystem (TypeScript/React), the other in a totally different language and ecosystem (Go), and we couldn't easily share business logic between them. As a small team, we need to ship fast. Having to re-implement every feature twice was just a massive tax on our velocity.</p><p>We started thinking about a new approach to Dagger Cloud, with two main goals:</p><ul><li data-preset-tag=\"p\"><p>Unify the codebases, to eliminate duplication and make it more efficient to ship new features</p></li><li data-preset-tag=\"p\"><p>Deliver on the promise of a crisp, snappy Web UI, matching the speed and performance of the terminal UI</p></li></ul><h4>Choosing Go + WebAssembly</h4><p>Our starting goal was to be able to reuse one codebase for both Dagger Cloud and the TUI. We decided fairly early to make it a Go codebase. Technically, we could have gone the other way and used TypeScript for the TUI. But we're primarily a team of Go engineers, so selecting Go made it easier for others in the team to contribute, to add a feature or drop in for a few hours to help debug an issue. In addition to standardizing on a single language, it gave us flexibility and broke down silos in our team.</p><p>Once we decided to run Go code directly in the browser, WebAssembly was the logical next step. But there were still a couple of challenges:</p><ul><li data-preset-tag=\"p\"><p>The Go + WebAssembly combination is still not as mature as React and other JavaScript frameworks. There are no ready-made component libraries to pull from, the developer tooling isn't as rich, and so on. We knew that we would need to build most of our UI components from scratch.</p></li><li data-preset-tag=\"p\"><p>There is a hard 2 GB memory limit for WebAssembly applications in most browsers. We expected this to be a problem when viewing large traces, and we knew we would have to do a lot of optimization to minimize memory usage and keep the UI stable. This wasn't entirely bad though; the silver lining here was that any memory usage improvements made to the WebAssembly UI would also benefit TUI users, since it was now a shared codebase.</p></li></ul><p>Once we'd made the decision, the next question was, \"how do we build this?\" We decided to build the new WebAssembly-based UI in the <a href=\"https://go-app.dev/\" rel=\"noopener\">Go-app framework</a>. Go-app is a high-level framework specifically for <a href=\"https://en.wikipedia.org/wiki/Progressive_web_app\" rel=\"noopener\">Progressive Web Apps (PWAs)</a> in WebAssembly. It offers key Go benefits, like fast compilation and native static typing, and it also follows a component-based UI model, like React, which made the transition easier.</p><p>Since the Go + WebAssembly combination isn't mainstream, there was some healthy skepticism within the Dagger team about its feasibility. For example, there was no real ecosystem for Go-app UI components and we knew we’d have to write our own, but we weren’t sure how easy or difficult this would be. We also had concerns over integrations with other services (Tailwind, Auth0, Intercom, PostHog), and about rendering many hundreds of live-updating components at the same time.&nbsp;</p><p>To answer these questions and de-risk the project, I spent almost a month prototyping, with the goal of re-implementing as much of the existing UI as possible in Go-app. As it turned out, there weren't many blockers: WebAssembly is already a <a href=\"https://webassembly.org/specs/\" rel=\"noopener\">well-documented open standard</a> and most other questions were answered in <a href=\"https://go-app.dev/reference\" rel=\"noopener\">Go-app’s own documentation</a>. The biggest challenge, as expected, was the memory usage limit, which required careful design and optimization.</p><h4>From Prototype to Production</h4><p>Once we had a working proof of concept, the team's comfort level increased significantly and we kicked off project \"awesome wasm\" to deliver a production implementation. Here are a few notes from the journey:</p><ul><li data-preset-tag=\"p\"><p>Memory usage was easily the most existential threat to the project’s success. I spent a lot of time figuring out how to render 200k+ lines of log output without crashing. This led to optimizations deep in our <a href=\"https://github.com/vito/midterm\" rel=\"noopener\">virtual terminal rendering library</a>, which dramatically reduced TUI memory usage at the same time (as mentioned already, sharing codebases means that important optimizations in one interface become \"free\" in the other!)</p></li><li data-preset-tag=\"p\"><p>Go WASM is slow at parsing large amounts of JSON, which led to dramatic architecture changes and the creation of a “smart backend” for incremental data loading over WebSockets, using Go's rarely-used <a href=\"https://pkg.go.dev/encoding/gob\" rel=\"noopener\">encoding/gob format</a>.</p></li><li data-preset-tag=\"p\"><p>Initially, the WASM file was around 32 MB. By applying <a href=\"https://github.com/google/brotli\" rel=\"noopener\">Brotli compression</a>, we were able to bring it down to around 4.6 MB. We tried to perform Brotli compression on-the-fly in our CDN but the file was too large, so eventually we just included the compression step into our build process.</p></li><li data-preset-tag=\"p\"><p>Apart from the memory challenges, most of our other initial worries turned out unfounded. The UI components weren’t very hard to write, integrations with other services were straightforward, and I found good techniques for handling component updates in real-time.</p></li><li data-preset-tag=\"p\"><p>There were a number of useful NPM packages I found, so I wondered if I could use them with Go. WebAssembly has a straightforward interface to both Go and JavaScript, so I built a <a href=\"https://daggerverse.dev/mod/github.com/vito/daggerverse/browserify@d368836636284116d090e271742904fea369cf72\" rel=\"noopener\">Dagger module that uses Browserify to load an NPM package</a>. This module allows us to generate a JavaScript file that can be included in a Go application. This means that we can work primarily in Go and then, if needed, we have a way to load helpers that are implemented in native JavaScript.</p></li><li data-preset-tag=\"p\"><p>Disclaimer: I'm not a React professional so with that in mind...it seemed to me that React had a very rigid way of implementing components, while Go-app was much more flexible. In Go-app, you can have any component update whenever you like, which gives you many more degrees of freedom for optimization. For example, I needed to optimize a component rendering 150,000+ lines of output. Just having the ability to try different approaches and then pick the one that worked best, made the entire exercise much easier!</p></li><li data-preset-tag=\"p\"><p>Even though Go-app doesn't have React-like developer tools built into the browser, I was able to use Go's own tools (pprof) plus the default profiler built into the browser for profiling and debugging. This was very useful to inspect functions calls, track CPU and memory usage, and evaluate the effectiveness of different approaches for optimizing memory usage.</p></li><li data-preset-tag=\"p\"><p>I discovered a side benefit of using Go-app: since Dagger Cloud is built as a PWA, it can be installed as a desktop or a mobile application. This makes it possible to launch Dagger Cloud like a native application and get a full-screen experience without needing to open a browser first, or just have a dedicated icon in your desktop taskbar/dock.</p></li></ul><p>We soft-launched Dagger Cloud v3 to our <a href=\"https://dagger.io/commanders\" rel=\"noopener\">Dagger Commanders</a> a few weeks ago to collect feedback and made it available to everyone shortly thereafter.</p><p>Our switch from React to WASM has resulted in a more consistent user experience across all Dagger interfaces, and better overall performance and lower memory usage, especially when rendering large and complex traces.</p><p>From an engineering perspective too, the benefits to our team are significant. Optimizations very often involve just as much, if not more, work than actually implementing features. So it's great to not have to spend time optimizing the Web UI, and then more time optimizing the TUI, and instead actually focus on delivering new features.</p><p>Dagger Cloud v3 has the Dagger community buzzing and one of the more common questions we've been fielding recently is: who should consider doing this and who shouldn't?</p><p>We want to be clear that we're not generally recommending making front-ends in Go. We had some very good reasons to do it: a team of strong Go engineers; a complex UI that TypeScript/React didn't scale well for; a requirement for standardization and reuse between two codebases; and a company-wide mandate to increase our velocity. That's a fairly specific set of circumstances. If you're in similar circumstances, this is certainly an option worth evaluating; if not, there are other tools and standards that you should consider first.</p><p>Dagger Cloud v3 is still in beta and we're excited for you to <a href=\"https://v3.dagger.cloud/\" rel=\"noopener\">try it out</a>. If you'd like to know more about our implementation or simply have feedback to share on the new UI, join our Discord and <a href=\"https://discord.com/invite/dagger-io\" rel=\"noopener\">let us know</a> what you think!</p>","contentLength":9715,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1imvmmq/we_replaced_our_react_frontend_with_go_and/"},{"title":"Context-switching is the main productivity killer for developers","url":"https://newsletter.techworld-with-milan.com/p/context-switching-is-the-main-productivity","date":1739266764,"author":"/u/oatridbed","guid":412,"unread":true,"content":"<p>Have you ever wondered what the biggest productivity killer for developers is? There are many, but one stands out—and it’s often underestimated.</p><p><strong>it costs that person 23 minutes of productive work,</strong></p><p>I’ve worked with development teams for over a decade, and we consistently underestimate the disruptive nature of interruptions. This article explores why context-switching is so costly and how to manage it effectively.</p><p><em>Authorization can significantly impact your application’s security and scalability. From managing dynamic permissions to implementing fine-grained access controls, the challenges grow as your requirements and users scale. This ebook is based on insights from 500+ interviews with engineers and IAM leads. It explores over 20 technologies and approaches, providing practical guidance to design a future-proof authorization system. Learn how to create a solution that evolves with your business needs while avoiding technical debt.</em></p><p><strong>Each shift forces your brain to refocus, sorting through your memory to figure out where you were</strong></p><p>The term context-switching is borrowed from operating systems (OS). OS can handle multiple processes in one processing unit (usually CPU) by putting one process on hold and processing another. Those systems can do context-switching, while our brains cannot.</p><p>We switch tasks more often than we realize because our tools, such as apps and notifications, are designed to grab our attention. Our brains love novelty and rush toward any new message or update. </p><p>We also feel pressure from work to respond immediately, which splits our focus even more (and our work cultures usually reward this). And there’s so much information—emails, chats, open tabs—that it’s easy to get distracted. </p><p><strong>lives in your working memory</strong><a href=\"https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two\" rel=\"\">hold only up to 7 items in short-term memory</a></p><p><strong>developers need an average of 23 minutes to rebuild their focus after an interruption fully</strong></p><p>When we are interrupted, we're not just losing minutes – we're degrading the quality of their work in several ways:</p><p><strong>developers who face frequent interruptions show signs of mental fatigue much earlier in the day, leading to more errors in their afternoon work</strong></p><p>A research study by Amoroso d'Aragona et al. (2023) [3] examined the impact of interruptions and breaks on software development and found striking correlations between context switching and code quality degradation. Their analysis revealed that:</p><ul><li><p><strong>Frequent breaks and interruptions</strong></p></li><li><p><strong>Prolonged gaps in activity</strong></p></li><li><p><strong>Interrupted coding sessions</strong><strong>lower code maintainability</strong></p></li></ul><p>These numbers aren't just statistics – they represent real problems that teams must fix later, creating a cycle of technical debt and cleanup work.</p><p><strong>&nbsp;A five-minute interruption during a critical problem-solving moment can create a long delay in task completion.</strong></p><p>We must discuss the flow state to understand why interruptions are so bad. This isn't just programmer jargon – it's a well-researched psychological state first described by Mihaly Csikszentmihalyi in 1990 [4].</p><p><strong>Flow state is a mental state in which work feels effortless and time seems to disappear&nbsp;</strong></p><p><strong>In that zone, you’re challenged enough to stay engaged, but not so much that you shut down</strong></p><p><strong>you must keep adjusting the difficulty of tasks as your abilities grow</strong></p><p><strong>the flow state is very fragile</strong></p><p><strong>on-screen interruptions significantly impact</strong></p><blockquote></blockquote><p>Let me share a story from a team I recently worked with. We tracked our interruptions for a month and found patterns that might sound familiar.</p><p><strong>Morning interruptions were particularly costly</strong></p><ul><li><p><strong>The story completion rate increased by 35%</strong></p></li><li><p><strong>Bug reports decreased by 28%</strong></p></li><li><p><strong>Team satisfaction scores improved by 45%</strong></p></li></ul><p>The image below shows the calendar with the protected focus time for deep work. </p><p>After studying this problem across multiple teams, I've found several approaches that consistently work:</p><ol><li><p><a href=\"https://www.patreon.com/techworld_with_milan/shop/how-to-set-and-achieve-any-goal-e-book-312287?utm_medium=clipboard_copy&amp;utm_source=copyLink&amp;utm_campaign=productshare_creator&amp;utm_content=join_link\" rel=\"\">daily goals</a></p></li><li><p><strong>📝 Capture tasks on the TODO list</strong><a href=\"https://www.todoist.com/\" rel=\"\">Todoist</a><a href=\"https://to-do.office.com/tasks/\" rel=\"\">Microsoft To Do</a></p></li><li><p><a href=\"https://www.patreon.com/techworld_with_milan/shop/how-to-set-priorities-e-book-312292?utm_medium=clipboard_copy&amp;utm_source=copyLink&amp;utm_campaign=productshare_creator&amp;utm_content=join_link\" rel=\"\">task prioritization method</a></p></li><li><p><strong>🅿️ The parking lot technique</strong></p></li><li><p><strong>🚧 Interruptible workflow:</strong><a href=\"https://en.wikipedia.org/wiki/Zeigarnik_effect\" rel=\"\">Zeigarnik Effect</a></p></li><li><p><a href=\"https://newsletter.techworld-with-milan.com/i/115140651/how-to-deal-with-parkinsons-law\" rel=\"\">Pomodoro Technique</a></p></li></ol><ol start=\"13\"><li><p><strong>🤔 Be intentionally responsive</strong><a href=\"https://amzn.to/3WJ64js\" rel=\"\">Algorithms to Live By</a><em>Be no more responsive than that</em></p></li><li><p><strong>🗓 Plan the day strategically</strong></p></li></ol><ol><li><p><strong>🚨 Interruption protocols:</strong></p></li><li><p><strong>📨 Asynchronous communication&nbsp;</strong><em>No need to respond to this message right away if you're in the middle of something</em></p></li><li><p><strong>🤝 Make meetings meaningful </strong></p></li></ol><blockquote><p><em>Learn how to be more productive: </em></p></blockquote><div data-attrs=\"{&quot;id&quot;:115140651,&quot;url&quot;:&quot;https://newsletter.techworld-with-milan.com/p/how-to-be-10x-more-productive&quot;,&quot;publication_id&quot;:1219834,&quot;publication_name&quot;:&quot;Tech World With Milan Newsletter&quot;,&quot;publication_logo_url&quot;:&quot;https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fafd6c17b-1bdf-4b80-a7cc-bd216bbe8edb_653x653.png&quot;,&quot;title&quot;:&quot;How to Be 10x More Productive &quot;,&quot;truncated_body_text&quot;:&quot;I was always amazed by top performers. I wondered what they do and how they are much better than others. Then, I started researching and talking directly to some of them. I finally managed to get some top performers as my mentors and, in the end, became one of them. I learned that they are not better than others, but they use some techniques that help t…&quot;,&quot;date&quot;:&quot;2023-04-27T15:00:29.677Z&quot;,&quot;like_count&quot;:65,&quot;comment_count&quot;:6,&quot;bylines&quot;:[{&quot;id&quot;:24455408,&quot;name&quot;:&quot;Dr Milan Milanović&quot;,&quot;handle&quot;:&quot;techworldwithmilan&quot;,&quot;previous_name&quot;:&quot;Dr. Milan Milanović&quot;,&quot;photo_url&quot;:&quot;https://bucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com/public/images/3a792453-001b-4564-9b05-3f2323b46763_1280x1124.png&quot;,&quot;bio&quot;:&quot;I'm a CTO writing for a 300k+ community to share my experiences and explore my curiosity. I have more than 20 years of experience in the industry and a strong scientific background (Ph.D. in Computer Sciences).&quot;,&quot;profile_set_up_at&quot;:&quot;2022-11-30T13:30:12.729Z&quot;,&quot;publicationUsers&quot;:[{&quot;id&quot;:1175459,&quot;user_id&quot;:24455408,&quot;publication_id&quot;:1219834,&quot;role&quot;:&quot;admin&quot;,&quot;public&quot;:true,&quot;is_primary&quot;:false,&quot;publication&quot;:{&quot;id&quot;:1219834,&quot;name&quot;:&quot;Tech World With Milan Newsletter&quot;,&quot;subdomain&quot;:&quot;techworldwithmilan&quot;,&quot;custom_domain&quot;:&quot;newsletter.techworld-with-milan.com&quot;,&quot;custom_domain_optional&quot;:false,&quot;hero_text&quot;:&quot;Insights into a beautiful world of Software Engineering, simplified. \\n\\nJoin his community of 300,000+ readers across different mediums.&quot;,&quot;logo_url&quot;:&quot;https://bucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com/public/images/afd6c17b-1bdf-4b80-a7cc-bd216bbe8edb_653x653.png&quot;,&quot;author_id&quot;:24455408,&quot;theme_var_background_pop&quot;:&quot;#D10000&quot;,&quot;created_at&quot;:&quot;2022-11-30T20:12:15.007Z&quot;,&quot;rss_website_url&quot;:null,&quot;email_from_name&quot;:&quot;Dr Milan Milanovic from Tech World With Milan&quot;,&quot;copyright&quot;:&quot;Dr Milan Milanović&quot;,&quot;founding_plan_name&quot;:null,&quot;community_enabled&quot;:true,&quot;invite_only&quot;:false,&quot;payments_state&quot;:&quot;disabled&quot;,&quot;language&quot;:null,&quot;explicit&quot;:false,&quot;is_personal_mode&quot;:false}}],&quot;twitter_screen_name&quot;:&quot;milan_milanovic&quot;,&quot;is_guest&quot;:false,&quot;bestseller_tier&quot;:null}],&quot;utm_campaign&quot;:null,&quot;belowTheFold&quot;:true,&quot;type&quot;:&quot;newsletter&quot;,&quot;language&quot;:&quot;en&quot;}\" data-component-name=\"EmbeddedPostToDOM\"><a native=\"true\" href=\"https://newsletter.techworld-with-milan.com/p/how-to-be-10x-more-productive?utm_source=substack&amp;utm_campaign=post_embed&amp;utm_medium=web\" rel=\"\"><div><div>How to Be 10x More Productive </div></div><div>I was always amazed by top performers. I wondered what they do and how they are much better than others. Then, I started researching and talking directly to some of them. I finally managed to get some top performers as my mentors and, in the end, became one of them. I learned that they are not better than others, but they use some techniques that help t…</div><div>2 years ago · 65 likes · 6 comments · Dr Milan Milanović</div></a></div><p>To know if your interruption management is working, track these metrics:</p><ul><li><p><strong>🔔 Unplanned interruptions</strong></p></li><li><p><strong>⏳ Duration of uninterrupted coding sessions.</strong></p></li><li><p><strong>😊 Team satisfaction scores.</strong></p></li><li><p><strong>🏃‍♂️ Sprint velocity trends.</strong></p></li></ul><p><a href=\"https://newsletter.techworld-with-milan.com/p/how-to-measure-developer-productivity?utm_source=publication-search\" rel=\"\">increased developer productivity</a></p><p><strong>they're a significant productivity killer that affects code quality, team morale, and project timelines</strong></p><ul></ul><p>So, start by implementing one or two of these suggestions. Measure the results. Adjust based on what works for your team. The goal isn't to eliminate all interruptions—it's to ensure that the interruptions that occur are worth their actual cost.</p><p>Let me know if you like it.</p><p><strong>more than 350,000+ tech professionals</strong></p><ol><li><p><a href=\"https://newsletter.techworld-with-milan.com/p/coaching-services\" rel=\"\">Book a working session with me</a></p></li></ol>","contentLength":5442,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1imuxui/contextswitching_is_the_main_productivity_killer/"},{"title":"VS Code update treats Copilot as \"out-of-the-box\" feature • DEVCLASS","url":"https://devclass.com/2025/02/07/vs-code-update-treats-copilot-as-out-of-the-box-feature/","date":1739252883,"author":"/u/stronghup","guid":413,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1imrqdj/vs_code_update_treats_copilot_as_outofthebox/"}],"tags":["dev","reddit"]}